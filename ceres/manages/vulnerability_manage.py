#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
import re
import json
from collections import defaultdict
from typing import List, Tuple

from ceres.conf.constant import REPO_ID_FOR_CVE_MANAGE, CommandExitCode
from ceres.function.check import PreCheck
from ceres.function.log import LOGGER
from ceres.function.status import (
    FAIL,
    NOT_PATCH,
    PARAM_ERROR,
    REPO_CONTENT_INCORRECT,
    REPO_NOT_SET,
    SUCCESS,
    StatusCode,
    COMMAND_EXEC_ERROR,
)
from ceres.function.util import execute_shell_command


class VulnerabilityManage:
    def repo_set(self, data: dict) -> int:
        """
        Save the repo source to local, and do simple verification.

        Args:
            data (dict): e.g
                {
                    "repo_info": {
                        "name": "string",
                        "dest": "save location",
                        "repo_content": "repo source info"
                    },
                    "check_items": ["string"],
                    "check": false
                }

        Returns:
            int: status code
        """
        repo_path = data.get("repo_info").get("dest")
        if re.match(r"/etc/yum.repos.d/[\w-]+.repo$", repo_path) is None:
            LOGGER.debug('Incorrect repo save path.')
            return PARAM_ERROR

        content = data.get("repo_info").get("repo_content")
        with open(repo_path, 'w', encoding='utf8') as repo_file:
            repo_file.write(content)
            LOGGER.info(f'Repo source {data.get("repo_info").get("name")} '
                        f'has been saved to {repo_path}.')

        if self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            LOGGER.info('Repo source set succeed.')
            return SUCCESS
        os.remove(data.get("repo_info").get("dest"))
        LOGGER.warning("Repo source can't be used, it has been deleted.")
        return REPO_CONTENT_INCORRECT

    @staticmethod
    def _validate_repo_source(repo_id: str) -> bool:
        """
        A sample validate which repo can used by yum.

        Args:
            repo_id(str): repo id

        Returns:
            bool
        """
        code, _, _ = execute_shell_command(f"yum repoinfo --repo {repo_id}")
        return code == CommandExitCode.SUCCEED

    def cve_scan(self, cve_scan_args: dict) -> Tuple[str, dict]:
        """
        query vulnerability info in the machine

        Args:
            cve_scan_args(dict): e.g
                {
                    check_items: ["network"]
                }

            check_items: Items that need to be checked before execution.

        Returns:
            int: status code
            dict: e.g
                {
                    "check_items": [{
                        "item": "network",
                        "result":False,
                        "log":"check log"
                        }],
                    "unfixed_cves": [{
                        "cve_id": "CVE-2023-1513",
                        "installed_rpm": "kernel-4.19.90-2304.1.0.0131.oe1.x86_64",
                        "available_rpm": "kernel-4.19.90-2304.1.0.0196.oe1.x86_64",
                        "support_way": "coldpatch",
                        }],
                    "fixed_cves": [
                        {
                            "cve_id": "CVE-2023-1112",
                            "installed_rpm":"redis-4.2.5-1.oe2203.x86_64",
                            "fix_way": "hotpatch",
                            "hp_status": "ACCEPTED" //only hotpatch has the field
                        },
                        {
                            "cve_id": "CVE-2023-1112",
                            "installed_rpm":"redis-4.2.5-1.oe2203.x86_64",
                            "fix_way": "coldpatch"
                        }
                    ]
                }
        """
        cve_scan_result = {}

        check_result, items_check_log = PreCheck.execute_check(cve_scan_args.get("check_items"))
        cve_scan_result["check_items"] = items_check_log
        if not check_result:
            LOGGER.info("The pre-check is failed before execute command!")
            return FAIL, cve_scan_result

        self.installed_rpm_info = self._query_installed_rpm()
        self.available_rpm_info = self._query_available_rpm()
        self.available_hotpatch_key_set = set()

        cve_scan_result.update(
            {
                "check_items": items_check_log,
                "unfixed_cves": self._query_unfixed_cves_by_dnf_plugin() or self._query_unfixed_cves_by_dnf(),
                "fixed_cves": self._query_fixed_cves(),
            }
        )
        return SUCCESS, cve_scan_result

    @staticmethod
    def _query_installed_rpm():
        """
        query installed rpm package info

        Returns:
            dict: all rpm info. e.g
                {
                    "kernel":"kernel-5.10.0-60.92.0.116.oe2203.aarch64"
                }
        """
        rpm_info = {}
        # Example of command execution result:
        # "kernel-tools":"kernel-tools-5.10.0-60.92.0.116.oe2203.aarch64",
        # "kernel-headers":"kernel-headers-5.10.0-60.92.0.116.oe2203.aarch64",
        # "kernel-devel":"kernel-devel-5.10.0-60.92.0.116.oe2203.aarch64",
        # "kernel":"kernel-5.10.0-60.92.0.116.oe2203.aarch64",
        code, stdout, _ = execute_shell_command(
            """
        rpm -qa --queryformat '"%{NAME}":"%{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}",'
        """
        )
        if code != CommandExitCode.SUCCEED:
            LOGGER.error("query installed packages info failed!")
            return rpm_info

        try:
            rpm_info = json.loads(f"{{{stdout[:-1]}}}")
        except json.decoder.JSONDecodeError as error:
            LOGGER.error(error)
            LOGGER.error("query installed packages info failed!")
            return rpm_info

        LOGGER.debug("query installed rpm package info succeed!")
        return rpm_info

    @staticmethod
    def _query_available_rpm():
        """
        query all avaiable rpms from update repo

        Returns:
            dict: avaiable rpm info. e.g
                {
                    "zstd": "zstd-1.5.0-4.oe2203.x86_64"
                    ...
                }
        """
        result = {}
        # Example of command execution result:
        # kernel.x86_64                                      5.10.0-60.105.0.132.oe2203       update
        # kernel-debuginfo.x86_64                            5.10.0-60.105.0.132.oe2203       update
        # kernel-debugsource.x86_64                          5.10.0-60.105.0.132.oe2203       update
        # kernel-devel.x86_64                                5.10.0-60.105.0.132.oe2203       update
        code, stdout, stderr = execute_shell_command("dnf list available")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error(stderr)
            return result
        
        # Example of regex matching result:
        # [
        # ("kernel", "x86_64.", "5.10.0-60.105.0.132.oe2203"),
        # ("kernel-debuginfo", "x86_64", "5.10.0-60.105.0.132.oe2203")
        # ]        
        rpm_info = re.findall("(kernel\S*)\.([a-z468_]+)\s+(\S+)", stdout)

        if not rpm_info:
            return result

        for rpm_name, arch, version_with_release in rpm_info:
            result[rpm_name] = f"{rpm_name}-{version_with_release}.{arch}"

        return result

    def _query_unfixed_cves_by_dnf(self) -> list:
        """
        parse unfixed kernel vulnerability info by dnf (coldpatch)

        Return:
            str: command execute result
            list: cve info e.g
                [{
                    "cve_id": "CVE-2023-1513",
                    "installed_rpm": "kernel-4.19.90-2304.1.0.0131.oe1.x86_64",
                    "available_rpm": "kernel-4.19.90-2304.1.0.0196.oe1.x86_64",
                    "support_way": "coldpatch",
                }]

        """
        # Example of command execution result:
        # Last metadata expiration check: 0:26:36 ago on Mon 07 Aug 2023 10:26:32 AM CST.
        # CVE-2021-43976  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-0941   Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-45469  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-44733  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        unfixed_cves = []
        code, stdout, stderr = execute_shell_command("dnf updateinfo list cves")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error("query unfixed cve info failed by dnf!")
            LOGGER.error(stderr)
            return unfixed_cves

        # Example of regex matching result:
        # [
        # ("CVE-2021-43976", "Important/Sec.", "kernel-4.19.90-2201.1.0.0132.oe1.x86_64"),
        # ("CVE-2021-0941", "Important/Sec.", "kernel-4.19.90-2201.1.0.0132.oe1.x86_64")
        # ]
        all_cve_info = re.findall(r"(CVE-\d{4}-\d+)\s+([\w+/.]+)\s+(kernel\S+)", stdout)
        if not all_cve_info:
            return unfixed_cves

        for cve_id, _, coldpatch in all_cve_info:
            rpm_name = coldpatch.rsplit("-", 2)[0]
            unfixed_cves.append(
                {
                    "cve_id": cve_id,
                    "installed_rpm": self.installed_rpm_info.get(rpm_name),
                    "available_rpm": self.available_rpm_info.get(rpm_name),
                    "support_way": "coldpatch",
                }
            )
        return unfixed_cves

    def _query_unfixed_cves_by_dnf_plugin(self) -> list:
        """
        parse unfixed kernel vulnerability info by dnf hotpatch plugin (hotpatch and coldpatch)

        Return:
            str: command execute result
            list: cve info e.g
                [{
                    "cve_id": "CVE-2023-1513",
                    "installed_rpm": "kernel-4.19.90-2304.1.0.0131.oe1.x86_64",
                    "available_rpm": "kernel-4.19.90-2304.1.0.0196.oe1.x86_64",
                    "support_way": "coldpatch",
                }]
        """

        def generate_single_vulnerability_info(rpm_name: str, support_way: str, hotpatch: str = ""):
            if support_way != "hotpatch":
                return {
                    "cve_id": cve_id,
                    "installed_rpm": self.installed_rpm_info.get(rpm_name),
                    "available_rpm": self.available_rpm_info.get(rpm_name),
                    "support_way": support_way,
                }
            return {
                "cve_id": cve_id,
                "installed_rpm": self.installed_rpm_info.get(rpm_name),
                "available_rpm": hotpatch,
                "support_way": support_way,
            }

        # Example of command execution result:
        # Last metadata expiration check: 0:31:50 ago on Mon 07 Aug 2023 10:26:32 AM CST.
        # CVE-2023-1981   Moderate/Sec.  avahi-libs-0.8-9.oe1.x86_64                     -
        # CVE-2021-42574  Important/Sec. binutils-2.34-19.oe1.x86_64                     -
        # CVE-2023-1513   Important/Sec. kernel-4.19.90-2304.1.0.0196.oe1.x86_64         patch-kernel-4.19.90-2112...
        cve_info_list = []
        code, stdout, stderr = execute_shell_command("dnf hot-updateinfo list cves")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error("query unfixed cve info failed by dnf!")
            LOGGER.error(stderr)
            return cve_info_list

        # Example of regex matching result:
        # [
        # ("CVE-2023-1513", "Important/Sec.", "kernel-4.19.90-2304.1.0.0196.oe1.x86_64", "patch-kernel-4.19.90-2112.."),
        # ("CVE-2021-42574", "Important/Sec.", "binutils-2.34-19.oe1.x86_64", "-")
        # ]
        all_cve_info = re.findall(r"(CVE-\d{4}-\d+)\s+([\w+/.]+)\s+(kernel\S+|-)\s+(patch-kernel\S+|-)", stdout)
        if not all_cve_info:
            return cve_info_list

        coldpatch_key_set, unavailable_hotpatch_key_set = set(), set()
        for cve_id, _, coldpatch, hotpatch in all_cve_info:
            rpm_name = coldpatch.rsplit("-", 2)[0]
            key = f"{cve_id}-{rpm_name}"
            if hotpatch != "-":
                if coldpatch == "-":
                    rpm_name = hotpatch.rsplit("-", 4)[1]
                    key = f"{cve_id}-{rpm_name}"
                cve_info_list.append(generate_single_vulnerability_info(rpm_name, "hotpatch", hotpatch))
                self.available_hotpatch_key_set.add(key)

            if coldpatch != "-" and key not in coldpatch_key_set:
                cve_info_list.append(generate_single_vulnerability_info(rpm_name, "coldpatch"))
                coldpatch_key_set.add(key)

            if (coldpatch == "-") and (hotpatch == "-") and (key not in unavailable_hotpatch_key_set):
                cve_info_list.append(generate_single_vulnerability_info(rpm_name, None))
                unavailable_hotpatch_key_set.add(key)

        return cve_info_list
    
    def _query_fixed_cves(self) -> list:
        """
        parse the fixed kernel vulnerability info by dnf

        Return:
            str: command execute result
            list: cve info e.g
                [
                    {"cve_id": "CVE-XXXX-XXXX","installed_rpm": "kernel-version-release.arch", "fix_way":"coldpatch"},
                    {"cve_id": "CVE-XXXX-XXXX","installed_rpm": "xxxx", "fix_way": "hotpatch", "hp_status": "ACCEPTED"}
                ]

        """
        # Example of command execution result:
        # Last metadata expiration check: 0:26:36 ago on Mon 07 Aug 2023 10:26:32 AM CST.
        # CVE-2021-43976  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-0941   Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-45469  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        # CVE-2021-44733  Important/Sec. kernel-4.19.90-2201.1.0.0132.oe1.x86_64
        fixed_cves = []
        code, stdout, stderr = execute_shell_command("dnf updateinfo list cves --installed")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error("query fixed cve info failed!")
            LOGGER.error(stderr)
            return self._query_applied_hotpatch()

        # Example of regex matching result:
        # [
        # ("CVE-2021-43976","Important/Sec.", "kernel-4.19.90-2201.1.0.0132.oe1.x86_64"),
        # ("CVE-2021-0941","Important/Sec.", "kernel-4.19.90-2201.1.0.0132.oe1.x86_64")
        # ]
        fixed_cves_info = re.findall(r"(CVE-\d{4}-\d+)\s+([\w+/.]+)\s+(kernel\S+)", stdout)

        if not fixed_cves_info:
            return self._query_applied_hotpatch()

        for cve_id, _, coldpatch in fixed_cves_info:
            rpm_name = coldpatch.rsplit("-", 2)[0]
            fixed_cves.append(
                {"cve_id": cve_id, "installed_rpm": self.installed_rpm_info.get(rpm_name), "fix_way": "coldpatch"}
            )
        fixed_cves.extend(self._query_applied_hotpatch())
        return fixed_cves
    
    def _query_applied_hotpatch(self) -> list:
        """
        parse kernel hotpatch info which has been applied by dnf hotpatch plugin (hotpatch)

        Return:
            list: hotpatch info list. e.g
                [{"cve_id": "CVE-XXXX-XXXX", "fix_way": "hotpatch", "hp_status": "ACCEPTED", "installed_rpm":"xxxx"}]

        """
        # Example of command execution result:
        # Last metadata expiration check: 0:28:36 ago on Mon 07 Aug 2023 10:26:32 AM CST.
        # CVE-id        base-pkg/hotpatch                                                 status
        # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-benchmark                             ACTIVED
        # CVE-2023-1112 redis-6.2.5-1/ACC-1-1/redis-benchmark                             ACTIVED
        # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-cli                                   ACTIVED
        # CVE-2023-1112 redis-6.2.5-1/ACC-1-1/redis-cli                                   ACTIVED
        # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-server                                NOT-APPLIED
        # CVE-2023-1112 redis-6.2.5-1/ACC-1-1/redis-server                                NOT-APPLIED
        # CVE-2023-2221 redis-6.2.5-1/ACC-1-2/redis-cli                                   NOT-APPLIED
        # CVE-2023-2222 redis-6.2.5-1/ACC-1-2/redis-cli                                   NOT-APPLIED
        # CVE-2023-1111 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-benchmark NOT-APPLIED
        # CVE-2023-1112 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-benchmark NOT-APPLIED
        # CVE-2023-1111 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-cli       NOT-APPLIED
        # CVE-2023-1112 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-cli       NOT-APPLIED
        # CVE-2023-1111 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-server    NOT-APPLIED
        # CVE-2023-1112 redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-server    NOT-APPLIED
        result = []
        code, stdout, stderr = execute_shell_command("dnf hotpatch --list cves")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error("query applied hotpatch info failed!")
            LOGGER.error(stderr)
            return result

        # Example of regex matching result:
        # [
        # ("CVE-2023-1112", "redis-6.2.5-1/SGL_CVE_2023_1111_CVE_2023_1112-1-1/redis-server", "NOT-APPLIED"),
        # ("CVE-2023-1111", "redis-6.2.5-1/ACC-1-1/redis-benchmark", "ACTIVED")
        # ]
        applied_hotpatch_info_list = re.findall(r"(CVE-\d{4}-\d+)\s+(kernel[\w\-/.]+)\s+([A-W]+)", stdout)

        if not applied_hotpatch_info_list:
            return result

        for cve_id, patch_name, hotpatch_status in applied_hotpatch_info_list:
            rpm = patch_name.split("-", 1)[0]
            # Refer to this example, the CVE can be marked as fixed only if all hotpatch are applied.
            # CVE-id        base-pkg/hotpatch                                                 status
            # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-benchmark                             ACTIVED
            # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-cli                                   ACTIVED
            # CVE-2023-1111 redis-6.2.5-1/ACC-1-1/redis-server                                NOT-APPLIED
            if f"{cve_id}-{rpm}" not in self.available_hotpatch_key_set and hotpatch_status in ("ACTIVED", "ACCEPTED"):
                result.append(
                    {
                        "cve_id": cve_id,
                        "installed_rpm": self.installed_rpm_info.get(rpm),
                        "fix_way": "hotpatch",
                        "hp_status": hotpatch_status,
                    }
                )
        return result

    def cve_fix(self, cves: List[dict]) -> Tuple[int, list]:
        """
        fix cve

        Args:
            cves(list): cve list which need to fix,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True},
                {
                    "cve_id": "CVE-1-2",
                    "hotpatch": False},
                }]

        Returns:
            int: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "fix succeed"
                }]

        """
        result_list = []
        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            for cve in cves:
                result_list.append(
                    {
                        "cve_id": cve.get("cve_id"),
                        "log": StatusCode.mapping.get(REPO_NOT_SET).get('msg'),
                        "result": 'fail',
                    }
                )
            return REPO_NOT_SET, result_list

        for cve in cves:
            command_execute_result = self._fix_cve_by_dnf(cve)
            result = {
                "cve_id": cve.get("cve_id"),
                "log": command_execute_result[1],
                "result": 'succeed' if command_execute_result[0] else 'fail'
            }
            result_list.append(result)

        return SUCCESS, result_list

    def _fix_cve_by_dnf(self, cve: dict) -> Tuple[bool, str]:
        """
        Fix CVE by dnf based on repo source named update

        Args:
            cve(dict): CVE ID and hotpatch, e.g.
                {"cve_id": "CVE-1-1",
                "hotpatch": True}

        Returns:
            bool: True or False
            command_execute_result: output from command execution

        """
        hotpatch = cve.get("hotpatch")
        if hotpatch:
            command = f"dnf hotupgrade --cve={cve.get('cve_id')} -y"
        else:
            command = f"dnf update --cve={cve.get('cve_id')} -y"

        code, stdout, stderr = execute_shell_command(command)
        res = stdout if code == CommandExitCode.SUCCEED else stderr

        if hotpatch:
            hot_pkg = self._hotpatch_list_cve_with_cveid(cve.get('cve_id'))
            if not hot_pkg:
                return False, res
            syscare_res = self._syscare_change_status(hot_pkg, cve.get('accepted'))
            if not syscare_res:
                return False, res
            return "Apply hot patch succeed" in res or "No hot patches marked for install" in res, res
        else:
            return "Complete" in res, res

    def cve_rollback(self, cves: List[dict]) -> Tuple[str, list]:
        """
        cve rollback

        Args:
            cves(list): cve list which need to rollback,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True
                }]

        Returns:
            str: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "rollback succeed"
                }]

        """

        if not self._validate_repo_source(REPO_ID_FOR_CVE_MANAGE):
            return REPO_NOT_SET, [dict(cve_id=cve["cve_id"], log=StatusCode.mapping[REPO_NOT_SET]['msg'], result="fail")
                                  for cve in cves]

        return self._cve_rollback(cves)

    def _cve_rollback(self, cves: List[dict]) -> Tuple[str, list]:
        """
        Roll back a restored cve

        Args:
            cves(list): cve list which need to rollback,e.g.
                [{
                    "cve_id": "CVE-1-1",
                    "hotpatch": True
                }]

        Returns:
            str: status code
            list: e.g
                [{
                    "cve_id": cve,
                    "result": "succeed",
                    "log": "rollback succeed"
                }]

        """
        hotpatch_list = self._hotpatch_list_cve()
        if not hotpatch_list:
            log = "No valid hot patch is matched."
            return NOT_PATCH, [dict(cve_id=cve["cve_id"], log=log, result="fail") for cve in cves]

        cmd_execute_result = []
        for base_pkg, hotpatch_cves in hotpatch_list.items():
            rollback_result, log = self._hotpatch_rollback(base_pkg)
            result = 'succeed' if rollback_result else 'fail'
            cmd_execute_result.extend([dict(cve_id=cve, log=log, result=result) for cve in hotpatch_cves])

        not_rollback_cve = set([cve["cve_id"] for cve in cves]).difference(
            set([cve_info["cve_id"] for cve_info in cmd_execute_result]))

        if not_rollback_cve:
            for cve in [cve for cve in cves if cve["cve_id"] in not_rollback_cve]:
                if cve["hotpatch"]:
                    log = "No valid hot patch is matched."
                else:
                    log = "Cold patch rollback is not supported."
                cmd_execute_result.append(dict(cve_id=cve["cve_id"], log=log, result="fail"))

        return SUCCESS, cmd_execute_result

    @staticmethod
    def _hotpatch_list_cve() -> dict:
        """
        Run the dnf hotpatch list cve command to query the hotpatch list corresponding to the cve

        Returns:
            dict: e.g
                {
                    "base-pkg/hotpatch-1": [cve_id1,cveid2],
                    "base-pkg/hotpatch-2": [cve_id1,cveid2]
                }
        """
        # Run the dnf command to query the hotpatch list,e.g
        # Last metadata expiration check:
        # CVE id   base-pkg/hotpatch  status
        # CVE-1        A-1.1-1/HP1    ACTIVED
        # CVE-2        A-1.1-1/HP1    ACTIVED
        code, hotpatch_list_output, _ = execute_shell_command(f"dnf hotpatch --list cve")
        if code != CommandExitCode.SUCCEED:
            LOGGER.error(f"Failed to hotpatch list cve.")
            return None

        if not re.search("base-pkg/hotpatch", hotpatch_list_output):
            return None
        hotpatch_list = defaultdict(list)
        for hotpatch_info in [line for line in hotpatch_list_output.split(os.linesep) if line]:
            if not hotpatch_info.startswith("CVE"):
                continue
            cve_id, base_pkg, status = [info.strip() for info in hotpatch_info.split()]
            if status != "ACTIVED" and status != "ACCEPTED":
                continue
            hotpatch_list[base_pkg].append(cve_id)

        return hotpatch_list

    @staticmethod
    def _hotpatch_list_cve_with_cveid(cve_id) -> str:
        """
        Run the dnf hotpatch list cve command to query the hotpatch list corresponding to the cve

        Returns:
            str
            e.g.
        """
        # Run the dnf command to query the hotpatch list,e.g
        # Last metadata expiration check:
        # CVE-id        base-pkg/hotpatch   status
        # CVE-2023-1111 redis-6.2.5-1/HP001 ACTIVED
        status_code, hotpatch_list_output, _ = execute_shell_command(f"dnf hotpatch --list cves --cve {cve_id}")
        if status_code != CommandExitCode.SUCCEED or not re.search("base-pkg/hotpatch", hotpatch_list_output):
            return None

        for hotpatch_info in [line for line in hotpatch_list_output.split(os.linesep) if line.startswith("CVE")]:
            _, hot_pkg, status = hotpatch_info.strip().split()
            if status == "ACTIVED":
                return hot_pkg
        return None

    def _syscare_operate(self, operate, patch_name=None):
        """

        """
        operate_code, _, _ = execute_shell_command("syscare save")
        if operate_code == CommandExitCode.FAIL:
            LOGGER.error(f"syscare save failed")
        operate_code, _, _ = execute_shell_command(f"syscare {operate} {patch_name}")
        if operate_code == CommandExitCode.FAIL:
            LOGGER.error(f"syscare {operate} {patch_name} failed,start roll back")
            execute_shell_command("syscare restore")
            if operate_code == CommandExitCode.FAIL:
                LOGGER.error(f"syscare restore failed,status roll back failed")
            else:
                LOGGER.info(f"syscare restore success")
            return False
        LOGGER.info(f"syscare {operate} {patch_name} success ")
        return True

    def _syscare_change_status(self, hot_pkg: str, accepted=False):
        """
       Apply hot patch use syscare accept

        Args:
            hot_pkg: cve is rolled back
        """
        res = self._syscare_operate("apply", hot_pkg)
        if not res:
            return False
        res = self._syscare_operate("active", hot_pkg)
        if not res:
            return False
        if accepted:
            res = self._syscare_operate("accept", hot_pkg)
            if not res:
                return False
        return True

    def _hotpatch_rollback(self, base_pkg_hotpatch: str) -> Tuple[bool, str]:
        """
        Hot patch is rolled back

        Args:
            cve_id: cve is rolled back
        """
        execute_result, hotpatch_release_info = self._hotpatch_info(base_pkg_hotpatch)
        if not execute_result:
            return False, "Failed to query patch information."

        hotpatch_name = "patch-%s-%s-%s-%s" % tuple(base_pkg_hotpatch.split("/") + list(hotpatch_release_info.values()))

        _, stdout, stderr = execute_shell_command(f"dnf remove {hotpatch_name} -y")
        return True, stdout + stderr 

    @staticmethod
    def _hotpatch_info(base_pkg_hotpatch: str) -> Tuple[bool, dict]:
        """
        Use syscare to query details about hotpatche

        Args:
            base_pkg_hotpatch: Basic hotpatch package

        Returns:
            bool: result of the command execution
            dict: {
                "version": 1,
                "release": 1
            }
        """
        # The standard output of syscare info command

        # syscare info A-1.1-1/HP1
        # uuid:        f4d17141-3356-4a49-a030-45496616e725
        # name:        HP001
        # version:     1
        # release:     1
        # arch:        x86_64
        # type:        UserPatch
        # target:      redis-6.2.5-1
        # target_elf:  redis-server
        # digest:      31fc7544
        # license:     BSD and MIT
        # description: (none)
        # patch:
        # 31fc7544 0001-Prevent-unauthenticated-client-from-easily-consuming.patch
        code, stdout, _ = execute_shell_command(f"syscare info {base_pkg_hotpatch}")

        hotpatch_release_info = dict()
        if code != CommandExitCode.SUCCEED:
            LOGGER.error(f"Failed to syacare info.")
            return False, hotpatch_release_info

        for hotpatch_info in stdout.split(os.linesep):
            try:
                info_property, info_value = hotpatch_info.split(":")
            except ValueError:
                continue
            if info_property in ["version", "release"]:
                hotpatch_release_info[info_property] = info_value.strip()
        return True, hotpatch_release_info
