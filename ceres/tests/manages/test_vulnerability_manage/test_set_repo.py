#!/usr/bin/python3
# ******************************************************************************
# Copyright (c) Huawei Technologies Co., Ltd. 2022-2022. All rights reserved.
# licensed under the Mulan PSL v2.
# You can use this software according to the terms and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#     http://license.coscl.org.cn/MulanPSL2
# THIS SOFTWARE IS PROVIDED ON AN 'AS IS' BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
# PURPOSE.
# See the Mulan PSL v2 for more details.
# ******************************************************************************/
import os
import unittest
from unittest import mock

from ceres.conf.constant import CommandExitCode
from ceres.manages.vulnerability_manage.set_repo_manage import SetRepoManage


class TestSetRepo(unittest.TestCase):

    @mock.patch("sys.exit")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(SetRepoManage, "_validate_repo_source")
    def test_repo_set_should_return_true_when_input_repo_content_can_be_used_by_yum(
        self, mock_validate_source, mock_remove
    ):
        mock_validate_source.return_value = True
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "[repo_id]mock_content",
            },
            "check_items": [],
        }
        result = SetRepoManage().set_repo(mock_args)
        self.assertEqual(True, result)

    @mock.patch.object(os, "remove")
    @mock.patch("builtins.open", mock.mock_open())
    @mock.patch.object(SetRepoManage, "_validate_repo_source")
    def test_repo_set_should_return_repo_content_is_incorrect_when_repo_content_cannot_be_used_by_yum(
        self, mock_validate_source, mock_remove
    ):
        mock_validate_source.return_value = False
        mock_remove.return_value = ''
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "/etc/yum.repos.d/mock.repo",
                "repo_content": "[repo_id]mock_content",
                "check": False,
            },
            "check_items": [],
        }
        result = SetRepoManage().set_repo(mock_args)
        self.assertEqual(False, result)

    def test_repo_set_should_return_param_error_when_repo_save_path_is_incorrect(self):
        mock_args = {
            "repo_info": {
                "repo_name": "mock_name",
                "dest": "mock_dest",
                "repo_content": "[repo_id]mock_content",
                "check": False,
            },
            "check_items": [],
        }
        result = SetRepoManage().set_repo(mock_args)
        self.assertEqual(False, result)

    @mock.patch('ceres.manages.vulnerability_manage.set_repo_manage.execute_shell_command')
    def test_validate_repo_source_should_return_true_when_query_repo_info_succeed(self, mock_execute_shell_command):
        mock_execute_shell_command.return_value = CommandExitCode.SUCCEED, "", ""
        result = SetRepoManage._validate_repo_source(["repo_id"])
        self.assertEqual(True, result)

    @mock.patch('ceres.manages.vulnerability_manage.set_repo_manage.execute_shell_command')
    def test_validate_repo_source_should_return_false_when_shell_command_execute_failed(
        self, mock_execute_shell_command
    ):
        mock_execute_shell_command.return_value = CommandExitCode.FAIL, "", ""
        self.assertEqual(False, SetRepoManage._validate_repo_source(['update']))


if __name__ == "__main__":
    unittest.main()
